Week One Report
//-------------------------------Question 1 #206 Reverse Linked List ---------------------------------//

Iterative solution(fast and less cost):

The idea for this problem is quite intuitive: To reverse the linked list, I only need to change every node's next pointer to its previous one.
Since singly-linked list only has one pointer points to the next node, I will lose the link to the rest of the list while I am changing a node's next
pointer. To handle this problem ,at least two additional pointers:
ListNode *sentinel = NULL; ----------- Represents the previous node of one node;
ListNode *next = NULL;     ----------- A node's next node;
are needed.

For every node(represented by ListNode *opt) in the linked list, the operation is as follows:
1) Assign next pointer to the node's next node: next = opt->next;
2) Change the node's next pointer to sentinel: opt->next = sentinel;
3) Change sentinel pointer to point at the current node which is the beginning of the new linked list.

The code is follows:

class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        if(!head) return NULL;
        ListNode *next = NULL;
        ListNode *sentinel = NULL;
        ListNode *opt = head;
        while(opt){
            next = opt->next;
            opt->next = sentinel;
            sentinel = opt;
            opt = next;
        }
        return sentinel;
    }
};


Recursive solution:

The idea of the recursive solution is to reverse every node behind after the given node, then add the given node to the end of the already-reversed-list,

The code is follows:

ListNode* reverseList(ListNode* head) {
        if (!head || !(head -> next)) return head;
        ListNode* node = reverseList(head -> next);
        head -> next -> next = head;
        head -> next = NULL;
        return node; 
    }
    
(I didn't work out this problem using recursion, the answer is just a rewritten of other's code in discuss section)
However, intuitively I think recursion consumes a large chunk of space in the stack, so I don't think it is the optimal solution for this problem.
What do you think?





//-------------------------------Question 2 #19 Remove Nth Node From End of List ---------------------------------//

This problem is similar to the problem in Cracking the Coding Interview 2.2.

Algorithm:

1) Create two pointers, index1, pointing to the beginning of the node and pre, whose next
   is the head.
2) Increment index1 by n positions, to make it point to the nth node from the beginning.
3) Check for index1 != NULL if no increment index and pre, if yes, pre is the (n + 1)th node
   to the end.
4) Remove nth node from the end by using pre->next = pre->next->next;

The code is follows:
   
ListNode* removeNthFromEnd(ListNode* head, int n) {
    ListNode *index1 = head;
    ListNode *pre = new ListNode(0);
    ListNode *res = pre;
    pre->next = head;
    for(int i = 0; i < n; i++){
        if(index1 == NULL) return NULL;
        index1 = index1->next;
    }
    while(index1){
        index1 = index1->next;
        pre = pre->next;
    }
    pre->next = pre->next->next;
    return res->next;
}


